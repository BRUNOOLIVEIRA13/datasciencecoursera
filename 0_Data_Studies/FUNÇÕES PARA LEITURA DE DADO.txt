### FUNÇÕES PARA LEITURA DE DADOS ###

read.table() e read.csv()    	-> lê dados tabelados
readLines() 					-> leitura de linhas em txt file
source()						-> lê codigos em R (inverso of dump)
dget()							-> lê códigos em R (inverso of dput)
load()							-> lê workspaces salvos
unserialize()					-> lê objetos em R que estão em binário


### LENDO UTILIZANDO read.table ####
'file', the name of a file, or a connection
'header', logical indicating if the file has a header line
'sep', a string indicating how the columns are separated
'colClasses', a character vector indicating the class of each column in the dataset
'nrows', the number of rows in the dataset. By default read.table() reads an entire file.
'comment.char', a character string indicating the comment character. This defalts to "#". If there are no commented lines in your file, it’s worth setting this to be the empty string "".
'skip', the number of lines to skip from the beginning
'stringsAsFactors', should character variables be coded as factors? This defaults to TRUE because back in the old days, if you had data that were stored as strings, it was because those strings represented levels of a categorical variable. Now we have lots of data that is text data and they don’t always represent categorical variables. So you may want to set this to be FALSE in those cases. If you always want this to be FALSE, you can set a global option via
'options(stringsAsFactors = FALSE)'.

'data <- read.table("foo.txt")' - SE os dados forem pequenos a médios, ele vai pular automaticamente as linhas iniciadas com # 

## QUANDO ESTA LENDO UTILIZANDO read.table é legal colocar nrows para ele saber o número de colunas, se não ele vai ler todas as colunas.
exemplo:
initial <- read.table("database.txt", nrows = 100)
## nrows

